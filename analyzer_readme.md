# Simulation Logic Overview

This document outlines the logic behind the simulation of spectroscopic data (IR, UV-Vis, and NMR) based on the molecular structure provided as a SMILES string. The simulation process involves several key steps:

1.  **Molecule Feature Analysis:** The input SMILES string is analyzed to identify the presence of key functional groups and structural features.
2.  **Characteristic Feature Mapping:** Based on the identified features, characteristic spectroscopic signals (peaks) are predicted. These predictions are based on general knowledge of how different functional groups interact with electromagnetic radiation and magnetic fields.
3.  **Spectrum Generation:** For IR and UV-Vis, a full spectrum curve is generated by mathematically modeling the shape and position of the predicted peaks. For NMR, a list of peaks with specific properties is generated directly.
4.  **Peak Labeling:** The generated peaks are labeled with their corresponding functional group assignments or transition types.

Let's delve into the details of each spectroscopic technique's simulation logic.

## 1. Molecule Feature Analysis

The `analyzeMolecule` function takes a SMILES string as input and returns an object of type `MoleculeFeatures`. This object contains boolean flags indicating the presence of various functional groups and structural motifs.

**Logic:**

The function employs a series of string inclusion checks and regular expressions to identify patterns within the SMILES string that are indicative of specific features.

**Examples:**

* `smiles.includes("C=O") || smiles.includes("C(=O)")`: Checks for the presence of a carbonyl group.
* `/O(?![(=]|\w?C(=O)|\w?O\w)/.test(smiles) || smiles.endsWith("OH")`: Attempts to identify hydroxyl groups while excluding those part of carbonyls, carboxylic acids, or ethers.
* `/[a-z]/.test(smiles) || /c1.*c1/.test(smiles) || smiles.includes('C1=CC=CC=C1')`: Checks for aromatic rings using lowercase letters (common in aromatic SMILES), ring closure notation, or explicit benzene representation.

**Output:**

An object with boolean properties like `hasOH`, `hasCarbonyl`, `hasAromatic`, etc.

## 2. IR Spectrum Simulation (`simulateIRSpectrum`)

The simulation of the IR spectrum involves predicting the wavenumbers, intensities (transmittance), and widths of characteristic absorption bands based on the identified molecular features.

**Logic:**

1.  **Feature-to-Peak Mapping:** Based on the `MoleculeFeatures`, an array of `IRPeakInfo` objects (`characteristicPeaks`) is populated. Each `IRPeakInfo` defines the expected `wavenumber` (in cm⁻¹), `targetTransmittance` (minimum % transmittance at the peak), `width` (Full Width at Half Maximum - FWHM in cm⁻¹), and `assignment` for a characteristic IR absorption.
    * **Example:** If `features.hasOH` is true, a peak around 3350 cm⁻¹ with a certain transmittance and width is added, assigned to 'O-H stretch (Alcohol/Phenol)'.
    * The predicted wavenumbers, transmittances, and widths are randomized within a certain range to introduce some variability and make the simulated spectra less ideal.

2.  **Lorentzian Peak Shape:** The shape of each IR absorption band is modeled using a Lorentzian function:
    $$
    L(x; x_0, \gamma, A) = A \cdot \left( \frac{\gamma^2}{(x - x_0)^2 + \gamma^2} \right)
    $$
    where:
    * $x$ is the wavenumber.
    * $x_0$ is the center wavenumber of the peak.
    * $\gamma$ is the half-width at half maximum (HWHM), which is $\frac{FWHM}{2}$.
    * $A$ is the amplitude of the peak (related to the intensity).

    The `lorentzianPeak` helper function implements this formula. The amplitude is calculated based on the `baselineLevel` (assumed to be 98% transmittance) and the `targetTransmittance` of the peak: $Amplitude = baselineLevel - targetTransmittance$.

3.  **Spectrum Curve Generation:**
    * A range of wavenumbers (typically 400 to 4000 cm⁻¹) is sampled at small intervals (0.5 cm⁻¹).
    * For each wavenumber point, the total transmittance is calculated by summing the contributions of all the Lorentzian-shaped characteristic peaks and subtracting this from the baseline.
    * Noise is added to the spectrum to make it more realistic. The noise consists of a random component and a sinusoidal component.
    * The transmittance values are clamped between 0.1% and 100%.

4.  **Peak Identification and Labeling:**
    * Local minima in the generated spectrum that are close to the center wavenumbers of the `characteristicPeaks` are identified as the simulated peaks.
    * A threshold based on the noise level is used to determine the significance of a minimum.
    * The identified minima are associated with their corresponding functional group assignments from the `characteristicPeaks`.

**Output:**

An `IRSpectrumData` object containing:

* `spectrum`: An array of `SpectrumPoint` (`[wavenumber, transmittance]`) representing the full IR spectrum curve.
* `peaks`: An array of `IRSpectrumPeak` (`{ wavenumber, transmittance, assignment }`) representing the identified and labeled peaks.

## 3. UV-Vis Spectrum Simulation (`simulateUVSpectrum`)

The simulation of the UV-Vis spectrum involves predicting the wavelengths and intensities (absorbance) of characteristic electronic transitions.

**Logic:**

1.  **Feature-to-Transition Mapping:** Based on the `MoleculeFeatures`, an array of potential electronic `transitions` is defined. Each transition has a `lambdaMax` (wavelength of maximum absorbance in nm), `intensity` (absorbance units), `width` (related to the standard deviation of the Gaussian peak), and `type` (the electronic transition, e.g., π→π*, n→π*).
    * **Example:** If `features.hasAromatic` is true, transitions around 255 nm (B band) and 205 nm (E band) are added.

2.  **Gaussian Peak Shape:** The shape of each UV-Vis absorption band is modeled using a Gaussian function:
    $$
    G(x; x_0, \sigma, A) = A \cdot \exp \left( - \frac{(x - x_0)^2}{2 \sigma^2} \right)
    $$
    where:
    * $x$ is the wavelength.
    * $x_0$ is the center wavelength ($\lambda_{max}$) of the peak.
    * $\sigma$ is the standard deviation, related to the `width` parameter. The exact relationship depends on how `width` is defined (e.g., FWHM ≈ 2.355 $\sigma$).
    * $A$ is the amplitude of the peak (intensity).

    The `gaussianPeak` helper function implements this formula.

3.  **Spectrum Curve Generation:**
    * A range of wavelengths (typically 200 to 800 nm) is sampled.
    * For each wavelength point, the total absorbance is calculated by summing the contributions of all the Gaussian-shaped transitions and adding a baseline absorbance.
    * Noise is added to the spectrum.
    * The absorbance values are clamped to be non-negative.

4.  **Peak Identification and Labeling:**
    * Local maxima in the generated absorbance spectrum that are above a certain threshold are identified as the simulated peaks ($\lambda_{max}$).
    * The identified peaks are associated with the closest matching electronic transition type from the defined `transitions`.

**Output:**

An `UVSpectrumData` object containing:

* `spectrum`: An array of `UVPoint` (`{ wavelength, absorbance }`) representing the full UV-Vis spectrum curve.
* `peaks`: An array of `UVPeak` (`{ wavelength, absorbance, assignment, transition }`) representing the identified and labeled peaks ($\lambda_{max}$).

## 4. NMR Spectrum Simulation (`simulateNMRSpectrum`)

The simulation of the NMR spectrum (both ¹H and ¹³C) directly generates a list of peaks with their characteristic properties. A full spectrum curve is not typically generated in this simplified simulation.

**Logic:**

1.  **Feature-to-Peak Mapping:** Based on the `MoleculeFeatures` and the specified NMR nucleus (`"1H"` or `"13C"`), an array of `NMRPeak` objects is populated. Each `NMRPeak` defines the expected `shift` (in ppm), relative `intensity`, `multiplicity` (e.g., "s", "d", "t", "m", "bs"), optional `coupling` constant (J in Hz, for ¹H NMR), and optional `atomIds` (for tracking simulated atoms).
    * **Example (¹H NMR):** If `features.hasAromatic` is true, a multiplet ('m') peak around 7.2 ppm is added, assigned to 'Aromatic H'.
    * **Example (¹³C NMR):** If `features.hasCarbonyl` is true, a singlet ('s') peak around 170-200 ppm (depending on the type of carbonyl) is added, assigned to 'Carbonyl C'.
    * The predicted chemical shifts and intensities are randomized within certain ranges. Multiplicities are assigned based on general rules (e.g., protons on adjacent carbons can cause splitting). Coupling constants are added optionally for ¹H NMR.

2.  **Specific Case Overrides:** For certain well-known molecules (e.g., acetone), there are specific overrides to provide more accurate simulated spectra by clearing the generic predictions and adding known characteristic peaks.

3.  **Sorting:** The generated peaks are sorted by chemical shift (descending order is the convention for NMR spectra).

**Output:**

An array of `NMRPeak` objects, where each object represents a peak in the NMR spectrum with its properties. For example:

```typescript
[
  { shift: 7.25, intensity: 1.5, multiplicity: 'm', assignment: 'Aromatic H' },
  { shift: 2.10, intensity: 3.0, multiplicity: 's', assignment: 'CH3' },
  // ... more peaks
]